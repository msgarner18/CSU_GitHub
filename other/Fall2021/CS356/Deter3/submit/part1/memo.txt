1. The two conditions that must be present for a program to be vulnerable to a software exploit, are that input must be copied using a vulnerable method that doesn't validate that the input is the correct size, and that the input is then subsequently used in a way that requires it's size to be within a particular range.
Inside the webserver.c code, there is a problem in the get_header method on the line where hdrval is defined that fulfills these requirements. Therefore, it is vulnerable to a buffer overflow attack.
What this code does, is it defines a value hdrval that is only allocated 1024. Then, based on the post request sent to the server, it uses memcpy to copy the request into the value hdrval. memcpy is a method that is vulnerable to buffer overflow attacks because it doesn't validate that hdrval has been allocated enough space to hold the amount of memory that is being copied into it.

To fix this problem, all you would need to do is replace the method memcpy with a safe method, or somehow confirm that the input is small enough, that you could successfully copy it into hdrval without using more memory than was allocated.

To demo this problem, I will describe a process that could be done that would achieve a buffer overflow attack that could successfully made against the server in order to crash it:
First, connect to the server
Second, send the server a post request in which the Content-Length field contains a number that is greater than 1024 digits in length.

The result of doing this is that the server will get a segmentation fault and crash.

2. This vulnerability found in the code is very serious. Buffer overflow attacks are one of the most common attacks. The demo demonstrated how this vulnerability could allow an attacker to crash the server. This could allow for the attacker to engage in a denial of service attack against our company. Additionally, there is an even greater danger than a denial-of-service attack. The attacker could instead make a post request that starts with a no-op sled, then a malicious shellcode, and finally a return address to the middle of the no-op sled created. If the length were calculated correctly, which shouldn't take an experienced hacker long, the attacker could overwrite the return address of the memcpy function to instead be the address of the middle of the no-op sled. The no-op sled would then simply move the control to the next no-op until the malicous code is reached. At this point, the attacker could gain access to root and be able to do any malicious activity they want that is allowed to them by the root which is to say, anything seeing that root privileges is the highest privilege available.

In order to mitigate this problem, we should fix the issue so that our server is no longer vulnerable to a buffer overflow attack, commit to using only safe methods from here on out in order to prevent issues like this from happening in the future, and finally, run diagnostics in order to see if any attacks have already been carried out and, if so, what needs to be done to recover from the attacks.

We may also consider programming in a different language that isn't vulnerable to buffer overflow attacks. We could instrument the function entry and exit code to setup and then check its stack frame for any evidence of corruption. We could block the execution of code on the stack, on the assumption that executable code should only be found elsewhere in the processes address space. We could place guard pages between critical regions of memory in a process's address space.
